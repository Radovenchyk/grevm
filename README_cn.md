# Grevm

> 中文版由大语言模型翻译。不准确的部分请参考英文原文。

Grevm 1.0 已经可以在 reth 中使用了，更多信息请参阅 [use-with-reth.md](use-with-reth.md)。

## Grevm 简介

我们很高兴发布 [Grevm 1.0 (Gravity EVM)](https://github.com/Galxe/grevm)。这是一个基于
[revm](https://github.com/bluealloy/revm) 的开源并行 EVM 运行时。Grevm 的核心算法受
[BlockSTM](https://arxiv.org/abs/2203.06871) 启发，并结合了从仿真数据中提取的交易依赖关系图作为启发式。这一改进使得
Grevm 在调度并行执行时更高效，减少了不必要的交易重新执行。

在基准测试中，Grevm 目前是**最快的**开源并行 EVM。对于完全并行化的交易，Grevm 比顺序执行快**4.13 倍**，运行速度达
到**26.50 gigagas/s**。在模拟 I/O 延迟为**100 μs**的情况下，Grevm 比顺序执行快**50.84 倍**，吞吐量达到**6.80
gigagas/s**。这种显著提升归功于并行执行和异步 I/O 的结合，通过并行化有效地叠加 I/O 操作，进一步提升了整体性能。

这标志着我们向**Gravity Chain**和**Gravity SDK**愿景迈出了重要一步。这套开源高性能 Layer 1 区块链工具包旨在支持新一代
Web3 应用。作为其中的关键组成部分，**Grevm** 使 Gravity Chain 实现每秒 1 gigagas 的吞吐量，为以太坊的可扩展性提供有力支
持。这些工具可帮助开发者构建高性能、再质押安全保障的 EVM Layer 1 解决方案。

Grevm 的开发得益于多个领先区块链项目的贡献。我们衷心感谢 [Paradigm](https://www.paradigm.xyz/) 和
[ithacaxyz](https://x.com/ithacaxyz) 提供的 [reth](https://github.com/paradigmxyz/reth) 和
[revm](https://github.com/bluealloy/revm)。此外，我们感谢 [Aptos](https://aptoslabs.com/) 为**BlockSTM**算法及其优化实现
提供的支持，以及 [Rise](https://www.riselabs.xyz/) 对 BlockSTM 在并行 EVM 执行中的探索
([pevm](https://github.com/risechain/pevm))，同时也感谢**BNB Chain 团队**
对[并行 EVM 性能](https://www.bnbchain.org/en/blog/road-to-high-performance-parallel-evm-for-bnb-chain)的深入研究。这些
努力为 Grevm 的设计提供了重要参考。

Grevm 1.0 目前是概念验证版本 (PoC)，其已知限制将在后续部分中详细讨论。我们正开发下一版本的 Grevm 2.0，预计将于 2024 年
12 月发布。

## 技术设计

![image.png](images/image.png)

_图 1: 理想的并行执行_

在深入探讨我们算法的具体细节之前，了解理想的并行执行场景十分有帮助。_图 1_ 展示了这一完美场景，其中交易在没有冲突的情况
下并行处理，有效地最大化吞吐量和资源利用率。

假设一组按顺序排列的交易为 **Tx₁**、**Tx₂**、……、**Txₙ**。理想的并行执行过程包括以下几点：

1. **精准分析交易依赖关系**：

   - 使用**有向无环图 (DAG)** 准确分析并表示交易之间的依赖关系，该图捕获了交易之间的数据 (读后写) 依赖。
   - 具体来说，当且仅当 **Txⱼ** (其中 **j > i**) 读取 **Txᵢ** 写入的存储槽时，**Txⱼ** 才依赖于 **Txᵢ**。这表示真正的读后
     写依赖。
   - _示例_：如果 **Tx₃** 读取了 Alice 的 ERC20 余额，而该余额将被 **Tx₂** 修改，那么 **Tx₃** 必须等待 **Tx₂** 完成，以
     确保数据一致性。

2. **将交易最佳分配到多个线程上**：

   - 调度器将交易**最佳地**分配到多个线程上，平衡计算 (CPU 密集型) 和输入/输出 (I/O 密集型) 工作负载。

3. **在软件事务内存 (STM) 系统上进行并行执行**：
   - 高性能的 **STM** 为每个线程提供多版本状态访问。
   - 在执行期间，每个交易可以读取所有前序交易的写入，但不能读取后续交易的写入，从而有效避免写后读冲突。
   - **写后写冲突解决**：
     - 如果多个交易写入相同的存储槽，STM 通过使用序号最高的交易 (即在序列中最新的交易) 的值来解决冲突。
     - 这确保最终状态反映原始交易顺序的正确结果。

然而，在实际的区块执行场景 (如运行验证节点或进行区块同步) 中，实现这种理想的并行执行面临诸多挑战，原因包括：

- **交易交互的不可预测性**：  
  由于高争用交易 (如 DEX 交换) 的动态特性，不逐个顺序执行交易很难精确确定数据依赖和资源需求。
- **实时分析开销**：  
  在实时中进行精确的依赖分析会引入显著的计算开销，可能抵消并行执行带来的性能优势。

针对这些限制，我们的方法利用仿真结果，在执行前将每个交易与最近可用的状态视图进行仿真。这些仿真提供了交易将读取或写入哪些
存储槽的估计，为构建数据依赖 DAG 提供输入。这些提示在并行执行之前即可计算，避免在执行期间引入额外的计算开销。

![image.png](images/glassnode-studio_eth-ethereum-transaction-type-breakdown-relative.png)

_截图 1: 理想的并行执行_

虽然并非所有提示都完全精准，但这些基于仿真的提示在实际应用中已足够准确。例如，在以太坊主网上，根据**历史 Gas 使用情
况**，大约 30% 的交易是简单的以太币转账，另有 25%-30% 是 ERC20 代币转账，这类交易通常涉及读取和写入有限数量的账户和存储
槽。因此，仿真结果在这类交易中具有稳定的准确性。

基于这些洞见，我们为 **Grevm** 开发了一个**三阶段并行执行框架**，这是对 **BlockSTM** 模型的后续改进，结合了从交易仿真中
获得的数据依赖提示：

- **阶段 1**: **提示生成和状态预加载**——通过仿真交易收集依赖提示并预热内存缓存。根据区块链的设计，这一阶段可以在不同时间
  点进行。例如，当新交易进入内存池时，可以立即运行仿真，提前准备依赖提示。
- **阶段 2**: **依赖分析**——将仿真阶段收集的依赖提示转换为 DAG，表示交易之间的依赖关系。该 DAG 作为后续并行执行的调度蓝
  图。
- **阶段 3**: **并发执行与冲突解决**——使用修改后的 BlockSTM 算法并行执行交易，利用阶段 2 中生成的依赖 DAG。调度器不再严
  格按照区块中的交易顺序 (如 1、2、3、……、n) 选择交易，而是根据 DAG 优先调度，以最小化冲突并减少重新执行的需求。

## 实现与评估

### Grevm 1.0：概念验证 (PoC) 实现

![grevm-process.svg](images/grevm-process.svg)

_图 2: Grevm 1.0 概念验证 (PoC) 实现_

为了验证上述框架并评估其实用影响，我们开发了 **Grevm 1.0** 作为初步的概念验证。源代码可在我们的 GitHub 上找到
：[https://github.com/Galxe/grevm](https://github.com/Galxe/grevm)。Grevm 已准备好与 reth 集成，详情请见
[https://github.com/Galxe/grevm/blob/main/use-with-reth.md](https://github.com/Galxe/grevm/blob/main/use-with-reth.md)。

这个初始版本的重点是测试我们的假设，同时尽量降低工程复杂度。尽管存在已知的局限性，Grevm 1.0 在并行交易执行方面表现出显著
的性能提升。

我们的框架的三个阶段会在多个轮次中迭代执行 (见图 2)。这种迭代方法简化了工程工作并提供了灵活的实验条件。对于每一轮，这三
个阶段具体实现如下：

1. **提示生成**

   - **第一轮**：我们在最近的已知状态上模拟每笔交易，以收集初始依赖提示，具体包括读取和写入集合。
   - **后续轮次**：我们使用前一轮执行中获得的读取和写入集合，而无需重新模拟。

2. **依赖分析**

   - **依赖图构建**：基于交易的读取和写入集合构建依赖图。
   - **交易分区**：将依赖图分解为弱连通分量 (WCCs)。每个 WCC 表示一组相互依赖的交易，这些交易必须一同考虑以避免冲突。
   - **贪心分区算法**：使用贪心算法将这些 WCC 分配到多个分区：
     - 分区数量设置为 **2 × CPU 核心数 + 1**，以最大化并行度。
     - 每笔交易根据估算的 Gas 使用量分配权重。
     - 尽量将总权重均匀分布到各个分区。

3. **并发执行**
   - **执行**：每个分区使用独立的执行器并行执行。在每个分区内部，交易按顺序执行，以尊重分区内的依赖关系。所有分区执行完
     毕后，尝试将各分区的更改合并到单一状态中。
   - **验证**：通过比较读取集合与其他分区的写入集合来验证交易。将交易分类为三种状态：
     - **已确认 (Finalized)**：未检测到冲突，且交易 ID 从上一个已确认交易起按顺序连续。
     - **未确认 (Unconfirmed)**：未检测到冲突，但交易 ID 不连续。
     - **冲突 (Conflict)**：检测到冲突，这些交易需要重新执行。
   - **合并**：若所有交易都已确认，则结束。否则，将所有已确认交易合并到新状态中，并回到第 1 步，对剩余的未确认和冲突交易
     进行下一轮处理，并更新其读取/写入集合。

上述阶段最多重复**三轮**。若三轮后仍未收敛 (即所有交易未全部确认)，则对剩余交易回退到顺序执行。

尽管如此，我们的简化实现存在一些已知局限性。通过基于弱连通分量 (WCCs) 进行分区，我们将 WCC 内的所有数据依赖视为相互传递
，这种方式过于保守。例如，当 30% 的交易访问相同的存储槽 (即热点比率为 30%) 时，大约一半的交易可能被分组到同一个 WCC 中，
极大限制了并行度，通常只能并行执行两个或更少的分区，导致资源利用不足。此外，如果依赖提示不够准确，系统在三轮并行执行后可
能无法解决冲突，最终回退到顺序执行，这种情况下性能甚至可能比 BlockSTM 更差。而在基准测试中，BlockSTM 即使在最坏情况下也
仅有大约 30% 的性能下降。

## 评估

我们在以下环境下对 1.0 版本进行了评估：

- **gcloud n2d-standard-32**：32 个 vCPU，时钟频率 2450MHz
- **操作系统**：Ubuntu 20.04.6 LTS
- **Cargo 版本**：1.81.0 (2dbb1af80 2024-08-20)
- **Grevm Git 提交哈希**：`ef3f2cb7b43a37f0acd69798d99678a1f1784f62`
- **pevm Git 提交哈希**：`d48fae90b6ad36ddc5d613ee28ad23214353e81e`
- **基准测试代
  码**：[https://github.com/Galxe/grevm/blob/main/benches/gigagas.rs](https://github.com/Galxe/grevm/blob/main/benches/gigagas.rs)

要复现基准测试，请运行以下命令：

```bash
JEMALLOC_SYS_WITH_MALLOC_CONF="thp:always,metadata_thp:always" NUM_EOA=${NUM_EOA} HOT_RATIO=${HOT_RATIO} DB_LATENCY_US=${DB_LATENCY_US} cargo bench --bench gigagas
```

请将 `${NUM_EOA}`、`${HOT_RATIO}` 和 `${DB_LATENCY_US}` 替换为所需的参数：

- **`NUM_EOA`**：账户数量。
- **`HOT_RATIO`**：访问公共（“热点”）账户的交易比例。
- **`DB_LATENCY_US`**：模拟的数据库延迟（单位：微秒）。

### Gigagas 区块测试

我们进行了 **gigagas 区块测试**，该基准测试用于评估在不同工作负载和条件下的并行执行效率。我们复用了部分来自 **pevm** 的
基准测试代码。每个模拟区块包含总计 **1 gigagas** 的交易 Gas 消耗。请注意，我们使用交易的实际 Gas 消耗来计算总 Gas，这包
括 Gas 退款。测试交易包括简单的以太币转账、ERC20 代币转账和 Uniswap 交换。

为消除磁盘 I/O 变化对执行性能的影响，预状态数据完全存储在内存中。为了模拟实际场景中磁盘 I/O 延迟对性能的影响，我们通过
`db_latency` 参数引入了人工延迟。

### 无冲突的工作负载

我们首先使用无冲突的工作负载对 Grevm 进行评估，以测试其在理想条件下的性能。在这种设置下，交易包括独立的原始转账、ERC20
代币转账和 Uniswap 交换。这些交易分别涉及不同的合约和账户，确保不存在数据依赖。这种基准测试能够衡量在没有冲突干扰的情况
下，并行执行所能达到的最佳性能。

| Test            | Num Txs | DB Latency | Sequential Execution (ms) | Parallel Execution (ms) | Execution Speedup | Total Gas     | Throughput (Gigagas/s) |
| --------------- | ------- | ---------- | ------------------------- | ----------------------- | ----------------- | ------------- | ---------------------- |
| Raw Transfers   | 47620   | 0          | 155.86                    | 37.73                   | 4.13              | 1,000,020,000 | 26.5                   |
|                 | 47620   | 100us      | 7476.21                   | 146.99                  | 50.84             | 1,000,020,000 | 6.8                    |
| ERC20 Transfers | 33628   | 0          | 285.64                    | 63.88                   | 4.47              | 906,276,572   | 14.19                  |
|                 | 33628   | 100us      | 10636.06                  | 208.94                  | 50.87             | 906,276,572   | 4.34                   |
| Uniswap Swaps   | 6413    | 0          | 679.99                    | 82.71                   | 8.22              | 1,000,004,742 | 12.09                  |
|                 | 6413    | 100us      | 24440.75                  | 420.91                  | 58.06             | 1,000,004,742 | 2.38                   |

_Table 1: Grevm 1.0 Conflict-Free Transaction Execution Speedup_

在**无冲突的条件**下，Grevm 1.0 的并行执行与顺序执行相比，展现了显著的性能提升，尤其是在引入模拟 I/O 延迟的情况下。对于
简单的原始转账，Grevm 1.0 的速度提高了 **4.13 倍**。当数据库访问延迟设定为 **100 微秒**时，加速效果更是达到 **50.84
倍**。ERC20 代币转账和 Uniswap 交换的性能测试结果也显示出类似的加速效果。

![image.png](images/image%201.png)

_Figure 3: IO Latency v.s. Speedup, Hot Ratio = 0%_

引入 I/O 延迟后，并行执行的优势更加明显。由于顺序执行需要线性处理，I/O 延迟会导致性能显著下降。而并行执行通过多个线程并
发操作，有效地将 I/O 延迟分散并重叠，从而减轻了延迟的负面影响。详情见**图 3**。

|                 | Num Txs | DB Latency | Sequential Execution pevm (ms) | Parallel Execution pevm (ms) | Execution Speedup | Throughput (Gigagas/s) |
| --------------- | ------- | ---------- | ------------------------------ | ---------------------------- | ----------------- | ---------------------- |
| Raw Transfers   | 47620   | 0          | 156.47                         | 55.488                       | 2.82              | 18.02                  |
|                 | 47620   | 100us      | 7484.1                         | 259.18                       | 28.88             | 3.85                   |
| ERC20 Transfers | 33628   | 0          | 278.24                         | 65.127                       | 4.27              | 15.35                  |
|                 | 33628   | 100us      | 10628                          | 683.13                       | 15.55             | 1.46                   |
| Uniswap Swaps   | 6413    | 0          | 665.96                         | 33.787                       | 19.71             | 29.59                  |
|                 | 6413    | 100us      | 26368                          | 839.49                       | 31.4              | 1.19                   |

_Table 2: pevm Benchmark Result of Conflict-Free Transaction Execution_

为了比较 **Grevm** 和标准 **BlockSTM** 算法的性能，我们使用 **pevm** 进行
了[相同的基准测试](https://github.com/risechain/pevm/pull/398)。在无冲突的情况下，Grevm 的表现和 BlockSTM 理论上应该接近
，这在原始转账和 ERC20 转账测试中得到了验证。然而，由于 Grevm 集成了异步 I/O，能够更高效地利用系统资源，因此在遇到 I/O
延迟时，Grevm 的性能优势更加明显。

对于 Uniswap 交易，Grevm 目前的状态合并仍然是顺序执行，这导致了较多不必要的数据拷贝。当更改的数据量较大时 (如 Uniswap 交
易)，这些拷贝显著影响了性能。不过，这一部分将在即将到来的 2.0 版本中进行彻底重构，因此我们不会对当前版本进行优化。

此外，我们发现，在基准测试中，某些交易 (如 ERC20 余额归零) 可能会退还 Gas。由于这些退还的 Gas 未被计入总 Gas 消耗，这可
能导致与 **pevm** 的吞吐量计算略有差异。我们计划在未来进行更详细的分析。

为了确保公平比较，**表 1** 中的测试结果排除了以下开销：

- **状态打包**：将缓存状态打包成可与 **reth** API 交互的状态所需的时间未计入，因为其他实现的基准测试不包含这一步骤。
- **初始提示解析和分区**：在流水线区块链中，初始仿真和分区过程通常会在执行前完成，因此未计入时间开销。

即便考虑这些额外开销，在数据库延迟存在时，Grevm 的加速效果依然非常显著。详见**表 3**。

| Test            | Num Txs | DB Latency | Sequential Total (ms) | Parallel Total (ms) | Total Speedup | Total Gas     | Throughput (Gigagas/s) |
| --------------- | ------- | ---------- | --------------------- | ------------------- | ------------- | ------------- | ---------------------- |
| Raw Transfers   | 47620   | 0          | 190.12                | 69.176              | 2.75          | 1,000,020,000 | 14.46                  |
|                 | 47620   | 100us      | 7512.8                | 179.03              | 41.96         | 1,000,020,000 | 5.59                   |
| ERC20 Transfers | 33628   | 0          | 317.13                | 96.559              | 3.28          | 906,276,572   | 9.39                   |
|                 | 33628   | 100us      | 10673                 | 243.27              | 43.87         | 906,276,572   | 3.73                   |
| Uniswap Swaps   | 6413    | 0          | 719.08                | 108.2               | 6.65          | 1,000,004,742 | 9.24                   |
|                 | 6413    | 100us      | 24485                 | 439.89              | 55.66         | 1,000,004,742 | 2.27                   |

_Table 3: Grevm 1.0 Conflict-Free Transaction E2E Total Speedup_

### 高争用交易

在 **gigagas 区块测试**中，为了模拟交易负载中的数据争用情况，我们引入了**热点比率**。该参数用于模拟一些账户或合约被频繁
访问的情况，从而反映不均匀的访问模式。

- **用户账户总数**：本次测试中使用了 **100,000** 个账户。
- **热点比率**：用于定义交易访问热点账户的概率：
  - **热点比率 = 0%**：表示所有交易的读/写操作均匀分布，随机访问不同账户。
  - **热点比率 > 0%**：表示存在部分热点账户，将总账户数的 **10%** 定义为热点账户，交易读/写操作有一定概率 (热点比率) 访
    问这些热点账户。

此外，我们设计了一个名为 **Hybrid** 的测试集，包含三类交易：

- **60% 原生转账**：简单的以太币账户间转账。
- **20% ERC20 转账**：在三个 ERC20 代币合约中进行的代币转账。
- **20% Uniswap 交换**：在两个独立的 Uniswap 交易对之间进行的交换操作。

| Test            | Num Txs | Total Gas     |
| --------------- | ------- | ------------- |
| Raw Transfers   | 47,620  | 1,000,020,000 |
| ERC20 Transfers | 33,628  | 1,161,842,024 |
| Hybrid          | 36,580  | 1,002,841,727 |

_Table 4: Contention Transactions Execution Test Setup_

| Test            | DB Latency | Sequential Execution(ms) | Parallel Execution(ms) | Execution Speedup | Throughput (Gigagas/s) |
| --------------- | ---------- | ------------------------ | ---------------------- | ----------------- | ---------------------- |
| Raw Transfers   | 0          | 207.25                   | 77.05                  | 2.69              | 12.98                  |
|                 | 100us      | 9610.52                  | 217.2                  | 44.29             | 4.6                    |
| ERC20 Transfers | 0          | 316.57                   | 92.63                  | 3.42              | 12.54                  |
|                 | 100us      | 12233.27                 | 263.9                  | 46.38             | 4.4                    |
| Hybrid          | 0          | 295.44                   | 206.71                 | 1.43              | 4.85                   |
|                 | 100us      | 10327.62                 | 1334.9                 | 7.73              | 0.75                   |

_Table 5: Grevm 1.0 Contention Transactions Execution Speedup (hot ratio = 0%)_

| Test            | DB Latency | Sequential Execution(ms) | Parallel Execution(ms) | Execution Speedup | Throughput (Gigagas/s) |
| --------------- | ---------- | ------------------------ | ---------------------- | ----------------- | ---------------------- |
| Raw Transfers   | 0          | 208.05                   | 77.86                  | 2.67              | 12.84                  |
|                 | 100us      | 9632.2                   | 217.31                 | 44.33             | 4.6                    |
| ERC20 Transfers | 0          | 313.59                   | 94.28                  | 3.33              | 12.32                  |
|                 | 100us      | 12289.76                 | 270.19                 | 45.5              | 4.3                    |
| Hybrid          | 0          | 294.52                   | 204.64                 | 1.44              | 4.9                    |
|                 | 100us      | 10333.63                 | 1315.46                | 7.85              | 0.76                   |

_Table 6: Grevm 1.0 Contention Transactions Execution Speedup (hot ratio = 10%)_

| Test            | DB Latency | Sequential Execution(ms) | Parallel Execution(ms) | Execution Speedup | Throughput (Gigagas/s) |
| --------------- | ---------- | ------------------------ | ---------------------- | ----------------- | ---------------------- |
| Raw Transfers   | 0          | 194.95                   | 171.65                 | 1.14              | 5.83                   |
|                 | 100us      | 8879.44                  | 4328.08                | 2.05              | 0.23                   |
| ERC20 Transfers | 0          | 313.48                   | 92.07                  | 3.41              | 12.62                  |
|                 | 100us      | 11434.4                  | 438.03                 | 26.14             | 2.65                   |
| Hybrid          | 0          | 292.63                   | 220.14                 | 1.33              | 4.56                   |
|                 | 100us      | 9742.6                   | 1874.7                 | 5.19              | 0.53                   |

_Table 7: Grevm 1.0 Contention Transactions Execution Speedup (hot ratio = 30%)_

![image.png](images/image%202.png)

_Figure 4: Hot Ratio v.s. Speedup_

![image.png](images/image%203.png)

_Figure 5: Hot Ratio v.s. Speedup, Latency=100us_

当**热点比率**为 **0%** (即均匀分布的工作负载) 时，Grevm 1.0 能维持高水平的并行性，并相较于顺序执行展现出显著的性能提升
。

然而，当热点比率增加到 **30%** 或更高时，并行执行性能出现明显下降。这是 1.0 版本的已知问题：Grevm 1.0 只能在交易依赖的弱
连通分量 (WCC) 之间进行并行执行，而 WCC 内的所有交易必须顺序执行，即使它们实际上可能是独立的。

具体来说，当热点比率为 **30%** 时，根据公式 `1−(1−0.3)^2=0.51`，有 **51%** 的概率交易会涉及热点账户。在这种情况下，假设
10% 的账户 (即 10,000 个账户) 被指定为热点账户，而交易数量高达 **47,620**，这意味着超过一半的交易会通过共享热点账户关联
在一起，形成一个大型分区。这种情况导致某个分区的执行时间异常延长，成为性能瓶颈，严重影响了整体并行性能。

这一问题将在即将发布的 **Grevm 2.0** 中得到解决。新版本将允许 WCC 内部的独立交易并行执行，从而提升并行性能。

## 未来工作

### 更深入的分析

随着 Grevm 1.0 的实现，我们有机会进行更深入的分析，为未来的设计提供依据：

- **内存使用和 DoS 风险**：评估系统的内存消耗，识别潜在的拒绝服务 (DoS) 攻击风险，防止因内存占用过高而导致系统崩溃。
- **重新执行和 CPU 效率**：分析重新执行的次数和整体 CPU 使用情况。Grevm 由于减少了不必要的重新执行，预期将显著降低 CPU
  负载。
- **依赖提示的准确度**：统计依赖提示的误判和漏判情况，分析它们对并行效率和执行次数的影响。

### Grevm 2.0 规划

![images/image%204.png](images/image%204.png)

_Figure 5：Grevm 2.0 _

Grevm 2.0 将通过以下关键改进来解决 1.0 版本的限制：

- **更细粒度的交易级并行**：即使交易之间存在共享依赖，只要依赖完成确认，它们就可以并行执行。这将大大提高并行性能，特别是
  在高争用的工作负载中，充分利用系统资源。
- **全面的异步 I/O 支持**：Grevm 2.0 将引入真正的异步 I/O，从底层数据库到多版本状态内存，全面实现异步操作。这将消除当前
  版本中非 I/O 操作时的多余协程切换，提高执行效率，降低延迟。

## 作者

[https://github.com/Richard](https://github.com/Richard19960401)

[https://github.com/AshinGau](https://github.com/AshinGau)

[https://github.com/nekomoto911](https://github.com/nekomoto911)

[https://github.com/stumble](https://github.com/stumble)
